import {
  Calendar as CalendarIcon,
  Network,
  PieChart,
  Plus,
  Sliders,
  Trash2,
  X
} from 'lucide-react-native';
import React, { useEffect, useMemo, useRef, useState } from 'react';

import { useAppData } from '@hooks/useAppData';
import { clearAppData, transformCustomFormat } from '@utils/storage';
import {
  Alert,
  Modal,
  PanResponder,
  Pressable,
  SafeAreaView,
  ScrollView,
  StatusBar,
  StyleSheet,
  Text,
  TextInput,
  View
} from 'react-native';



// --- CONSTANTS ---

const APP_COLORS = ['#BFA2DB', '#D1D9F2', '#A8E6CF', '#E6B8B7', '#E6C8DC', '#EFD9CE'] as const;
const CATEGORY_COLORS = ['#BFA2DB', '#D1D9F2', '#A8E6CF', '#E6B8B7', '#E6C8DC', '#EFD9CE'] as const;
const NODE_SIZE = 72;
const TIME_STEP_MIN = 1;

type CategoryMap = {
  [categoryName: string]: string; // category name -> color
};


type Project = {
  id: number;
  name: string;
  time: string;
  percent: number;
  hexColor: string;
  category: string | null;
  x: number;
  y: number;
};

type EventItem = {
  id: number;
  title: string;
  start: number; // minutes from 0:00
  duration: number; // minutes
  hexColor: string;
  details?: string; // tag/details from import
  category?: string; // category/type from import
  date: string; // YYYY-MM-DD format for date tracking
  projectId?: number; // link to project
};

type Link = {
  source: number;
  target: number;
};

const DEFAULT_PROJECTS: Project[] = [];

const DEFAULT_EVENTS: EventItem[] = [];

const DEFAULT_LINKS: Link[] = [];

const DEFAULT_CATEGORIES: CategoryMap = {};

// --- Shared small helpers ---

const formatMinutes = (total: number) => {
  const m = ((total % (24 * 60)) + 24 * 60) % (24 * 60);
  const h = Math.floor(m / 60);
  const mm = m % 60;
  return `${String(h).padStart(2, '0')}:${String(mm).padStart(2, '0')}`;
};

// --- UI Shared Components ---

type HeaderProps = {
  title: string;
  subtitle?: string;
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
};

const Header: React.FC<HeaderProps> = ({ title, subtitle, leftIcon, rightIcon }) => {
  return (
    <View style={styles.header}>
      <View style={styles.headerLeft}>
        {leftIcon && <View style={{ marginRight: 8 }}>{leftIcon}</View>}
        <View>
          <Text style={styles.headerTitle}>{title}</Text>
          {subtitle ? <Text style={styles.headerSubtitle}>{subtitle}</Text> : null}
        </View>
      </View>
      {rightIcon && <View>{rightIcon}</View>}
    </View>
  );
};

type TabKey = 'calendar' | 'analytics';

const TabBar: React.FC<{ activeTab: TabKey; setActiveTab: (t: TabKey) => void }> = ({
  activeTab,
  setActiveTab,
}) => {
  const mkTab = (key: TabKey, label: string, Icon: any) => {
    const active = activeTab === key;
    return (
      <Pressable style={styles.tabItem} onPress={() => setActiveTab(key)}>
        <Icon size={24} strokeWidth={active ? 2.5 : 2} color={active ? '#000' : '#9CA3AF'} />
        <Text style={[styles.tabLabel, { color: active ? '#000' : '#9CA3AF' }]}>{label}</Text>
      </Pressable>
    );
  };

  return (
    <View style={styles.tabBar}>
      {mkTab('calendar', 'Today', CalendarIcon)}
      {mkTab('analytics', 'Analytics', PieChart)}
    </View>
  );
};

// --- Calendar View (Today) ---

type DraftEvent = {
  id: number | null;
  start: number;          // å¼€å§‹æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
  end: number;            // ç»“æŸæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰
  selectedProjectId: number | null;
  isNewProject: boolean;
  newProjectName: string;
  details?: string; // tag/details for event
  category?: string; // category for event
  title?: string;
  date: string; // YYYY-MM-DD format
  projectId?: number; // link to project
  isNewCategory?: boolean; // for creating new category
  newCategoryName?: string;
  newCategoryColor?: string; // hex color for new category
};



type CalendarViewProps = {
  events: EventItem[];
  setEvents: React.Dispatch<React.SetStateAction<EventItem[]>>;
  projects: Project[];
  setProjects: React.Dispatch<React.SetStateAction<Project[]>>;
  categories: CategoryMap;
  setCategories: React.Dispatch<React.SetStateAction<CategoryMap>>;
};

const CalendarView: React.FC<CalendarViewProps> = ({
  events,
  setEvents,
  projects,
  setProjects,
  categories,
  setCategories,
}) => {
  const [editingField, setEditingField] = useState<'start' | 'end' | null>(null);
  const [tempTime, setTempTime] = useState('');
  const [currentTime, setCurrentTime] = useState(() => new Date());
  const [selectedDate, setSelectedDate] = useState(() => new Date());
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [draftEvent, setDraftEvent] = useState<DraftEvent | null>(null);
  const [isCalendarOpen, setIsCalendarOpen] = useState(false);
  const scrollRef = useRef<ScrollView | null>(null);
  const timeListRef = useRef<ScrollView | null>(null);

  // Date navigation functions
  const handlePrevDay = () => {
    const prev = new Date(selectedDate);
    prev.setDate(prev.getDate() - 1);
    setSelectedDate(prev);
  };

  const handleNextDay = () => {
    const next = new Date(selectedDate);
    next.setDate(next.getDate() + 1);
    setSelectedDate(next);
  };

  const handleTodayClick = () => {
    setSelectedDate(new Date());
  };

  // Pan responder for swipe gesture
  const panResponderRef = useRef<any>(null);
  useEffect(() => {
    panResponderRef.current = PanResponder.create({
      onStartShouldSetPanResponder: () => true,
      onMoveShouldSetPanResponder: (evt, gestureState) => {
        return Math.abs(gestureState.dx) > 10; // Minimum 10px horizontal movement
      },
      onPanResponderRelease: (evt, gestureState) => {
        const minDistance = 50; // Minimum swipe distance
        if (gestureState.dx > minDistance) {
          // Swiped right - go to previous day
          handlePrevDay();
        } else if (gestureState.dx < -minDistance) {
          // Swiped left - go to next day
          handleNextDay();
        }
      },
    });
  }, [selectedDate, handlePrevDay, handleNextDay]);

  // Scroll when field changes (START/END tap)
  useEffect(() => {
    // The scrolling will happen automatically in onContentSizeChange
  }, [editingField]);



  const timeOptions = useMemo(
    () =>
      Array.from(
        { length: (48 * 60) / TIME_STEP_MIN }, // æ”¯æŒè·¨è¶Šåˆå¤œçš„äº‹ä»¶ï¼ˆæœ€å¤š48å°æ—¶ï¼‰
        (_, i) => i * TIME_STEP_MIN,
      ),
    [],
  );
  const pixelsPerMinute = 1;
  const hours = Array.from({ length: 24 }, (_, i) => i);

  useEffect(() => {
    const t = setInterval(() => setCurrentTime(new Date()), 60000);
    return () => clearInterval(t);
  }, []);

  useEffect(() => {
    if (!scrollRef.current) return;
    const now = new Date();
    const minutesSinceStart = now.getHours() * 60 + now.getMinutes();
    const scrollPos = minutesSinceStart * pixelsPerMinute;
    scrollRef.current.scrollTo({ y: Math.max(0, scrollPos), animated: false });
  }, []);

  // When date changes, scroll to current time (if viewing today) or to 6:00 (if viewing other days)
  useEffect(() => {
    if (!scrollRef.current) return;
    const now = new Date();
    const isToday =
      selectedDate.getFullYear() === now.getFullYear() &&
      selectedDate.getMonth() === now.getMonth() &&
      selectedDate.getDate() === now.getDate();

    let scrollPos = 0;
    if (isToday) {
      const minutesSinceStart = now.getHours() * 60 + now.getMinutes();
      scrollPos = minutesSinceStart * pixelsPerMinute;
    } else {
      scrollPos = 6 * 60 * pixelsPerMinute; // Default to 6:00 for other days
    }
    scrollRef.current.scrollTo({ y: Math.max(0, scrollPos), animated: true });
  }, [selectedDate]);

  const nowMinutes = currentTime.getHours() * 60 + currentTime.getMinutes();
  const nowTop = nowMinutes * pixelsPerMinute;

  const openNewEventAt = (totalMinutes: number) => {
    const dateStr = `${selectedDate.getFullYear()}-${String(selectedDate.getMonth() + 1).padStart(
      2,
      '0',
    )}-${String(selectedDate.getDate()).padStart(2, '0')}`;
    setEditingField(null);
    setDraftEvent({
      id: null,
      start: totalMinutes,
      end: totalMinutes + 60,   // é»˜è®¤ä¸€å°æ—¶ï¼Œä¹‹åå¯ä»¥æ”¹
      selectedProjectId: null,
      isNewProject: false,
      newProjectName: '',
      details: '',
      category: '',
      title: '',
      date: dateStr,
      isNewCategory: false,
      newCategoryName: '',
      newCategoryColor: APP_COLORS[0],
    });
    setIsModalOpen(true);
  };



  const handleSlotPress = (hour: number, minute: number) => {
    openNewEventAt(hour * 60 + minute);
  };

  const handleAddNow = () => {
    const now = new Date();
    const total = now.getHours() * 60 + now.getMinutes();
      const rounded = Math.ceil(total / TIME_STEP_MIN) * TIME_STEP_MIN; 
    openNewEventAt(rounded);
  };

  const handleEventPress = (evt: EventItem) => {
    const matchingProject = projects.find((p) => p.name === evt.title);
    setEditingField(null);
    setDraftEvent({
      id: evt.id,
      start: evt.start,
      end: evt.start + evt.duration,   // ç”¨ç»å¯¹ç»“æŸæ—¶é—´
      selectedProjectId: matchingProject ? matchingProject.id : null,
      isNewProject: false,
      newProjectName: '',
      details: evt.details || '',
      category: evt.category || '',
      title: evt.title,
      date: evt.date,
      isNewCategory: false,
      newCategoryName: '',
      newCategoryColor: APP_COLORS[0],
    });
    setIsModalOpen(true);
  };



  const handleDelete = () => {
    if (!draftEvent?.id) return;
    setEvents((prev) => prev.filter((e) => e.id !== draftEvent.id));
    setIsModalOpen(false);
    setDraftEvent(null);
    setEditingField(null); 
  };

  const handleSave = () => {
    if (!draftEvent) return;
    setIsModalOpen(false);
    setDraftEvent(null);
    setEditingField(null);  
    let title = draftEvent.title || 'New Event';
    let color = '#9CA3AF'; // é»˜è®¤ç°è‰²
    let selectedCategory = draftEvent.category;

    // Handle new category
    if (draftEvent.isNewCategory && draftEvent.newCategoryName?.trim()) {
      const catName = draftEvent.newCategoryName.trim();
      const catColor = draftEvent.newCategoryColor || APP_COLORS[0];
      setCategories((prev) => ({ ...prev, [catName]: catColor }));
      selectedCategory = catName;
    }

    if (draftEvent.isNewProject && draftEvent.newProjectName.trim()) {
      const newProject: Project = {
        id: Date.now(),
        name: draftEvent.newProjectName,
        time: '0h 0m',
        percent: 0,
        hexColor: '#9CA3AF', // é»˜è®¤ç°è‰²ï¼ŒåæœŸè·Ÿç€ category å˜è‰²
        category: null,
        x: 150,
        y: 150,
      };
      setProjects((prev) => [...prev, newProject]);
      title = newProject.name;
      // é¢œè‰²è·Ÿç€ category èµ°ï¼Œä¸è·Ÿç€ project èµ°
    } else if (draftEvent.selectedProjectId) {
      const proj = projects.find((p) => p.id === draftEvent.selectedProjectId);
      if (proj) {
        title = proj.name;
        // é¢œè‰²è·Ÿç€ category èµ°ï¼Œä¸è·Ÿç€ project èµ°
      }
    }

    // é¢œè‰²ç”± category å†³å®šï¼Œå¦‚æœé€‰äº† category å°±ç”¨ category çš„é¢œè‰²
    if (selectedCategory && categories[selectedCategory]) {
      color = categories[selectedCategory];
    }

    const rawDuration = draftEvent.end - draftEvent.start;
    const duration = Math.max(1, rawDuration); // è‡³å°‘ 1 åˆ†é’Ÿï¼Œé˜²æ­¢ end <= start

    const payload: Omit<EventItem, 'id'> = {
      title,
      start: draftEvent.start,
      duration,
      hexColor: color,
      details: draftEvent.details || undefined,
      category: selectedCategory || undefined,
      date: draftEvent.date,
      projectId: draftEvent.selectedProjectId || undefined,
    };


    setEvents((prev) => {
      if (draftEvent.id) {
        return prev.map((e) => (e.id === draftEvent.id ? { ...e, ...payload } : e));
      }
      return [...prev, { id: Date.now(), ...payload }];
    });

    setIsModalOpen(false);
    setDraftEvent(null);
  };

  const handleReset = () => {
    Alert.alert('Reset all data?', 'This cannot be undone.', [
      { text: 'Cancel', style: 'cancel' },
      {
        text: 'Reset',
        style: 'destructive',
        onPress: () => {
          setEvents([]);
          setProjects([]);
        },
      },
    ]);
  };


  const openTimeEditor = (field: 'start' | 'end') => {
    setEditingField(field);
  };


  const handleSelectTime = (field: 'start' | 'end', minutes: number) => {
    if (!draftEvent) return;

    if (field === 'start') {
      setDraftEvent({ ...draftEvent, start: minutes });
    } else {
      setDraftEvent({ ...draftEvent, end: minutes });
    }
    setEditingField(null);
  };


  const parseTimeString = (value: string): number | null => {
    const trimmed = value.trim();
    if (!trimmed) return null;

    // æ”¯æŒ 9:30 / 09:30 / 930(ä¸å»ºè®®ä½†å…¼å®¹) è¿™ç±»
    const match = trimmed.match(/^(\d{1,2})(?::?(\d{2}))?$/);
    if (!match) return null;

    const h = parseInt(match[1], 10);
    const m = match[2] ? parseInt(match[2], 10) : 0;

    if (h < 0 || h > 23 || m < 0 || m > 59) return null;
    return h * 60 + m;
  };

  const applyTempTime = () => {
    if (!draftEvent || !editingField) return;
    const minutes = parseTimeString(tempTime);
    if (minutes == null) {
      Alert.alert('Invalid time', 'Please enter time like 14:30');
      return;
    }

    if (editingField === 'start') {
      setDraftEvent({ ...draftEvent, start: minutes });  // åªæ”¹ start
    } else {
      setDraftEvent({ ...draftEvent, end: minutes });    // åªæ”¹ end
    }
    setEditingField(null);
  };




  const dateStr = selectedDate.toLocaleDateString('en-US', {
    weekday: 'long',
    month: 'long',
    day: 'numeric',
  });

  const monthStr = selectedDate.toLocaleDateString('en-US', { month: 'long' });
  const dayStr = selectedDate.toLocaleDateString('en-US', { day: '2-digit' });
  const weekdayStr = selectedDate.toLocaleDateString('en-US', { weekday: 'short' });

  // Get days in current month for mini calendar
  const getDaysInMonth = (date: Date) => {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
  };

  const getFirstDayOfMonth = (date: Date) => {
    return new Date(date.getFullYear(), date.getMonth(), 1).getDay();
  };

  const daysInMonth = getDaysInMonth(selectedDate);
  const firstDay = getFirstDayOfMonth(selectedDate);
  const calendarDays = Array.from({ length: daysInMonth }, (_, i) => i + 1);

  return (
    <View style={{ flex: 1, backgroundColor: '#FFFFFF' }} {...panResponderRef.current?.panHandlers}>
      <View style={styles.header}>
        <Pressable 
          style={styles.headerLeft} 
          onPress={() => setIsCalendarOpen(!isCalendarOpen)}
        >
          <View>
            <Text style={[styles.headerTitle, { fontWeight: 'bold' }]}>{monthStr}</Text>
            <Text style={styles.headerSubtitle}>{dayStr} {weekdayStr}</Text>
          </View>
        </Pressable>
        <View style={{ flexDirection: 'row', alignItems: 'center', gap: 4 }}>
          <Pressable style={styles.todayButton} onPress={handleTodayClick}>
            <Text style={styles.todayButtonText}>Today</Text>
          </Pressable>
          <Pressable style={styles.fabSmall} onPress={handleAddNow}>
            <Plus size={18} color="#FFFFFF" />
          </Pressable>
        </View>
      </View>

      {/* Mini Calendar Modal - Backdrop and Dropdown */}
      {isCalendarOpen && (
        <>
          {/* Overlay backdrop - closes calendar when tapped */}
          <Pressable
            style={styles.calendarBackdrop}
            onPress={() => setIsCalendarOpen(false)}
          />
          
          {/* Calendar dropdown */}
          <View 
            style={styles.calendarDropdown}
          >
            <View style={styles.calendarHeader}>
              <Pressable onPress={() => {
                const prev = new Date(selectedDate);
                prev.setMonth(prev.getMonth() - 1);
                setSelectedDate(prev);
              }}>
                <Text style={styles.calendarNavText}>â†</Text>
              </Pressable>
              <Text style={styles.calendarMonth}>
                {selectedDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}
              </Text>
              <Pressable onPress={() => {
                const next = new Date(selectedDate);
                next.setMonth(next.getMonth() + 1);
                setSelectedDate(next);
              }}>
                <Text style={styles.calendarNavText}>â†’</Text>
              </Pressable>
            </View>

            {/* Weekday labels */}
            <View style={styles.calendarWeekdays}>
              {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((day) => (
                <Text key={day} style={styles.calendarWeekdayLabel}>{day}</Text>
              ))}
            </View>

            {/* Calendar grid */}
            <View style={styles.calendarGrid}>
              {/* Empty cells for days before month starts */}
              {Array.from({ length: firstDay }).map((_, i) => (
                <View key={`empty-${i}`} style={styles.calendarEmptyCell} />
              ))}

              {/* Day cells */}
              {calendarDays.map((day) => {
                const isSelected =
                  selectedDate.getDate() === day &&
                  selectedDate.getMonth() === new Date().getMonth() &&
                  selectedDate.getFullYear() === new Date().getFullYear();
                const isToday = 
                  day === new Date().getDate() &&
                  selectedDate.getMonth() === new Date().getMonth() &&
                  selectedDate.getFullYear() === new Date().getFullYear();
                
                // Check if this day has events and find most common category
                const dayDateStr = `${selectedDate.getFullYear()}-${String(selectedDate.getMonth() + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const dayEvents = events.filter(evt => evt.date === dayDateStr);
                const hasEvents = dayEvents.length > 0;
                
                // Count categories to find the most common one
                let dotColor = '#EF4444'; // default red
                if (hasEvents) {
                  const categoryCount: { [key: string]: number } = {};
                  dayEvents.forEach(evt => {
                    const cat = evt.category || 'default';
                    categoryCount[cat] = (categoryCount[cat] || 0) + 1;
                  });
                  
                  // Find most common category
                  const mostCommonCategory = Object.entries(categoryCount).sort((a, b) => b[1] - a[1])[0]?.[0];
                  if (mostCommonCategory && mostCommonCategory !== 'default' && categories[mostCommonCategory]) {
                    dotColor = categories[mostCommonCategory];
                  }
                }

                return (
                  <Pressable
                    key={day}
                    style={[
                      styles.calendarDay,
                      isSelected && styles.calendarDaySelected,
                      isToday && styles.calendarDayToday,
                    ]}
                    onPress={() => {
                      const newDate = new Date(selectedDate);
                      newDate.setDate(day);
                      setSelectedDate(newDate);
                      setIsCalendarOpen(false);
                    }}
                  >
                    <Text
                      style={[
                        styles.calendarDayText,
                        isSelected && styles.calendarDayTextSelected,
                      ]}
                    >
                      {day}
                    </Text>
                    {hasEvents && (
                      <View style={[styles.calendarEventDot, { backgroundColor: dotColor }]} />
                    )}
                  </Pressable>
                );
              })}
            </View>
          </View>
        </>
      )}

      <ScrollView ref={scrollRef} style={{ flex: 1 }} contentContainerStyle={{ paddingBottom: 24 }}>
        <View style={{ minHeight: 1440, paddingHorizontal: 12, paddingTop: 0 }}>
          {hours.map((hour) => (
            <View
              key={hour}
              style={[
                styles.hourRow,
                { height: 60 * pixelsPerMinute, borderColor: '#E5E7EB' },
              ]}
            >
              <View style={styles.hourLabelContainer}>
                <Text style={styles.hourLabel}>{`${hour}:00`}</Text>
              </View>
              <View style={styles.hourTrack}>
                <Pressable
                  style={{ flex: 1 }}
                  onPress={(e) => {
                    // Get the Y position within this hour track
                    const locationY = e.nativeEvent.locationY;
                    // Calculate minutes within this hour (0-59)
                    let minutesInHour = Math.round((locationY / 60) * 60);
                    // Round to nearest 5-minute increment
                    minutesInHour = Math.round(minutesInHour / 5) * 5;
                    // Clamp to 0-59 range
                    minutesInHour = Math.min(59, Math.max(0, minutesInHour));
                    handleSlotPress(hour, minutesInHour);
                  }}
                />
              </View>
            </View>
          ))}

          {events
            .filter((evt) => {
              const eventDate = evt.date;
              const selectedDateStr = `${selectedDate.getFullYear()}-${String(
                selectedDate.getMonth() + 1,
              ).padStart(2, '0')}-${String(selectedDate.getDate()).padStart(2, '0')}`;
              return eventDate === selectedDateStr;
            })
            .map((evt) => {
            const top = evt.start * pixelsPerMinute;
            const height = evt.duration * pixelsPerMinute;
            if (top < 0) return null;
            return (
              <Pressable
                key={evt.id}
                onPress={() => handleEventPress(evt)}
                style={[
                  styles.eventCard,
                  {
                    top,
                    height: Math.max(20, height),
                    backgroundColor: `${evt.hexColor}4D`,
                    borderLeftColor: evt.hexColor,
                  },
                ]}
              >
                {evt.details && (
                  <Text style={styles.eventTitle} numberOfLines={1}>
                    {evt.details}
                  </Text>
                )}
                <Text style={[styles.eventTime, { fontSize: 11, marginTop: 2 }]} numberOfLines={1}>
                  {evt.projectId ? projects.find(p => p.id === evt.projectId)?.name : evt.title}
                </Text>
                <Text style={styles.eventTime}>
                  {formatMinutes(evt.start)} - {formatMinutes(evt.start + evt.duration)}
                </Text>
              </Pressable>
            );
          })}

          <View style={[styles.nowLine, { top: nowTop }]}>
            <View style={styles.nowDot} />
          </View>
        </View>
      </ScrollView>

      {/* Event Modal */}
      <Modal visible={isModalOpen && !!draftEvent} transparent animationType="slide">
        <Pressable 
          style={styles.modalOverlay}
          onPress={() => {
            setIsModalOpen(false);
            setDraftEvent(null);
            setEditingField(null);
          }}
        >
          <View 
            style={styles.bottomSheetLarge}
            onStartShouldSetResponder={() => true}
            onResponderRelease={() => {}}
          >
            {/* é¡¶éƒ¨æ ‡é¢˜ + åˆ é™¤ + å…³é—­ */}
            <View style={styles.sheetHeader}>
              <Text style={styles.sheetTitle}>
                {draftEvent?.id ? 'Edit Event' : 'Add Event'}
              </Text>
              <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
                {draftEvent?.id && (
                  <Pressable style={styles.iconDanger} onPress={handleDelete}>
                    <Trash2 size={18} color="#DC2626" />
                  </Pressable>
                )}
                <Pressable
                  style={styles.iconButton}
                  onPress={() => {
                    setIsModalOpen(false);
                    setDraftEvent(null);
                    setEditingField(null); 
                  }}
                >
                  <X size={20} color="#6B7280" />
                </Pressable>
              </View>
            </View>

            {draftEvent && (
              <ScrollView
                style={{ flex: 1 }}
                contentContainerStyle={{ paddingBottom: 24 }}
              >
                {/* ---- æ—¶é—´å¤§å¡ç‰‡ ---- */}
                {/* ---- æ—¶é—´å¤§å¡ç‰‡ ---- */}
                <View style={[styles.card, styles.timeCard]}>
                  <View style={styles.timeHeaderRow}>
                    <Text style={styles.timeHeaderLabel}>START</Text>
                    <Text style={styles.timeHeaderLabel}>END</Text>
                  </View>

                  <View style={styles.timeMainRow}>
                    {/* START */}
                    <Pressable
                      style={styles.timeBlock}
                      onPress={() => openTimeEditor('start')}
                    >
                      <Text style={styles.timeBig}>
                        {formatMinutes(draftEvent.start)}
                      </Text>
                    </Pressable>

                    <Text style={styles.timeArrow}>â†’</Text>

                    {/* END */}
                    <Pressable
                      style={styles.timeBlock}
                      onPress={() => openTimeEditor('end')}
                    >
                      <Text style={styles.timeBig}>
                        {formatMinutes(draftEvent.end)}
                      </Text>
                    </Pressable>
                  </View>
                </View>

                {/* ğŸ‘‰ ä¸‹æ‹‰æ—¶é—´é€‰æ‹©å™¨ï¼Œç±»ä¼¼ Google Calendar çš„é€‰æ‹©åˆ—è¡¨ */}
                {editingField && (
                  <View style={styles.timePickerContainer}>
                    <Text style={styles.timePickerTitle}>
                      {editingField === 'start'
                        ? 'Select start time'
                        : 'Select end time'}
                    </Text>
                    <ScrollView
                      key={editingField}
                      ref={timeListRef}
                      style={{ maxHeight: 260 }}
                      scrollEnabled={true}
                      showsVerticalScrollIndicator={false}
                      contentContainerStyle={{ paddingVertical: 0 }}
                      onContentSizeChange={(width, height) => {
                        if (height === 0) return;
                        
                        // Only scroll if we have an active editing field
                        if (!editingField || !draftEvent) return;
                        
                        const current =
                          editingField === 'start' ? draftEvent.start : draftEvent.end;
                        const nearestIndex = Math.round(current / TIME_STEP_MIN);
                        const totalItems = (48 * 60) / TIME_STEP_MIN; // æ”¯æŒè·¨è¶Šåˆå¤œçš„äº‹ä»¶
                        const actualRowHeight = height / totalItems;
                        const scrollY = nearestIndex * actualRowHeight;

                        timeListRef.current?.scrollTo({ y: scrollY, animated: false });
                      }}
                    >
                      {timeOptions.map((m) => {
                        const current =
                          editingField === 'start'
                            ? draftEvent.start
                            : draftEvent.end;

                        const nearest =
                          Math.round(current / TIME_STEP_MIN) * TIME_STEP_MIN;
                        const active = m === nearest;

                        return (
                          <Pressable
                            key={`${editingField}-${m}`}
                            style={[
                              styles.timeOptionRow,
                              active && styles.timeOptionRowActive,
                            ]}
                            onPress={() => handleSelectTime(editingField, m)}
                          >
                            <Text
                              style={[
                                styles.timeOptionText,
                                active && styles.timeOptionTextActive,
                              ]}
                            >
                              {formatMinutes(m)}
                            </Text>
                          </Pressable>
                        );
                      })}
                    </ScrollView>
                  </View>
                )}




                {/* ---- Event Details / Tag ---- */}
                <View style={styles.card}>
                  <Text style={styles.sectionLabel}>Details / Tag</Text>
                  <TextInput
                    style={styles.input}
                    placeholder="Enter event details or tag..."
                    value={draftEvent.details || ''}
                    onChangeText={(txt) =>
                      setDraftEvent({ ...draftEvent, details: txt })
                    }
                    multiline
                  />
                </View>

                {/* ---- Project é€‰æ‹© ---- */}
                <View style={styles.card}>
                  <Text style={styles.sectionLabel}>Project</Text>
                  <View style={styles.projectGrid}>
                    {projects.map((p) => {
                      const active =
                        !draftEvent.isNewProject &&
                        draftEvent.selectedProjectId === p.id;
                      return (
                        <Pressable
                          key={p.id}
                          style={[
                            styles.projectChip,
                            active && styles.projectChipActive,
                          ]}
                          onPress={() =>
                            setDraftEvent({
                              ...draftEvent,
                              isNewProject: false,
                              selectedProjectId: p.id,
                            })
                          }
                        >
                          <View
                            style={[
                              styles.projectDot,
                              { backgroundColor: p.hexColor },
                            ]}
                          />
                          <Text
                            numberOfLines={1}
                            style={styles.projectChipText}
                          >
                            {p.name}
                          </Text>
                        </Pressable>
                      );
                    })}

                    <Pressable
                      style={[
                        styles.newProjectChip,
                        draftEvent.isNewProject && styles.newProjectChipActive,
                      ]}
                      onPress={() =>
                        setDraftEvent({ ...draftEvent, isNewProject: true })
                      }
                    >
                      <Plus
                        size={14}
                        color={
                          draftEvent.isNewProject ? '#2563EB' : '#6B7280'
                        }
                      />
                      <Text
                        style={[
                          styles.newProjectText,
                          draftEvent.isNewProject && { color: '#2563EB' },
                        ]}
                      >
                        New Project
                      </Text>
                    </Pressable>
                  </View>

                  {draftEvent.isNewProject && (
                    <TextInput
                      style={styles.input}
                      placeholder="Enter Project Name"
                      value={draftEvent.newProjectName}
                      onChangeText={(txt) =>
                        setDraftEvent({ ...draftEvent, newProjectName: txt })
                      }
                    />
                  )}
                </View>

                {/* ---- Event Category ---- */}
                <View style={styles.card}>
                  <Text style={styles.sectionLabel}>Category</Text>
                  <View style={{ flexDirection: 'row', gap: 8, flexWrap: 'wrap' }}>
                    {Object.keys(categories).map((catName) => {
                      const catColor = categories[catName];
                      const isSelected = draftEvent.category === catName;
                      return (
                        <Pressable
                          key={catName}
                          style={[
                            {
                              paddingHorizontal: 12,
                              paddingVertical: 6,
                              borderRadius: 8,
                              backgroundColor: `${catColor}20`,
                              borderColor: catColor,
                              borderWidth: 2,
                            },
                            isSelected && { backgroundColor: catColor, borderColor: catColor },
                          ]}
                          onPress={() => {
                            setDraftEvent({ 
                              ...draftEvent, 
                              category: catName,
                              isNewCategory: false,
                              newCategoryName: '',
                            });
                          }}
                        >
                          <Text
                            style={[
                              { color: catColor, fontWeight: '600', fontSize: 12 },
                              isSelected && { color: '#FFFFFF' },
                            ]}
                          >
                            {catName}
                          </Text>
                        </Pressable>
                      );
                    })}
                    
                    <Pressable
                      style={[
                        styles.newProjectChip,
                        draftEvent.isNewCategory && styles.newProjectChipActive,
                      ]}
                      onPress={() =>
                        setDraftEvent({ ...draftEvent, isNewCategory: true })
                      }
                    >
                      <Plus
                        size={14}
                        color={
                          draftEvent.isNewCategory ? '#2563EB' : '#6B7280'
                        }
                      />
                      <Text
                        style={[
                          styles.newProjectText,
                          draftEvent.isNewCategory && { color: '#2563EB' },
                        ]}
                      >
                        New Category
                      </Text>
                    </Pressable>
                  </View>

                  {draftEvent.isNewCategory && (
                    <View style={{ marginTop: 12, gap: 8 }}>
                      <TextInput
                        style={styles.input}
                        placeholder="Category name"
                        value={draftEvent.newCategoryName || ''}
                        onChangeText={(txt) =>
                          setDraftEvent({ ...draftEvent, newCategoryName: txt })
                        }
                      />
                      <Text style={{ fontSize: 12, color: '#6B7280', marginLeft: 4 }}>
                        Color
                      </Text>
                      <View style={{ flexDirection: 'row', gap: 8, flexWrap: 'wrap' }}>
                        {APP_COLORS.map((color) => (
                          <Pressable
                            key={color}
                            style={[
                              {
                                width: 36,
                                height: 36,
                                borderRadius: 8,
                                backgroundColor: color,
                              },
                              draftEvent.newCategoryColor === color && {
                                borderColor: '#000000',
                                borderWidth: 3,
                              },
                            ]}
                            onPress={() =>
                              setDraftEvent({ ...draftEvent, newCategoryColor: color })
                            }
                          />
                        ))}
                      </View>
                    </View>
                  )}
                </View>
              </ScrollView>
            )}

            {/* åº•éƒ¨ä¸»æŒ‰é’® */}
            <Pressable style={styles.primaryButton} onPress={handleSave}>
              <Text style={styles.primaryButtonText}>
                {draftEvent?.id ? 'Update Event' : 'Add Event'}
              </Text>
            </Pressable>
          </View>
        </Pressable>
      </Modal>

          </View>
  );
};

// --- Analytics View ---

type AnalyticsViewProps = {
  projects: Project[];
  events: EventItem[];
};

const AnalyticsView: React.FC<AnalyticsViewProps> = ({ projects, events }) => {
  const [timeRange, setTimeRange] = useState<'Week' | 'Month'>('Week');
  const days = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];

  // Filter events based on timeRange
  const filteredEvents = (() => {
    const today = new Date();
    const rangeInDays = timeRange === 'Week' ? 7 : 30;
    const startDate = new Date(today);
    startDate.setDate(startDate.getDate() - rangeInDays);

    return events.filter((evt) => {
      const eventDate = new Date(evt.date);
      return eventDate >= startDate && eventDate <= today;
    });
  })();

  // Calculate weekly data based on filtered events
  const weeklyData = (() => {
    const data = [0, 0, 0, 0, 0, 0, 0]; // Mon-Sun

    filteredEvents.forEach((evt) => {
      const eventDate = new Date(evt.date);
      const dayOfWeek = eventDate.getDay();
      // Convert Sunday (0) to index 6, and Mon (1) to index 0
      const idx = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
      if (idx >= 0 && idx < 7) {
        data[idx] += evt.duration;
      }
    });

    return data;
  })();

  const maxVal = Math.max(...weeklyData);

  // Calculate total focus time (based on filtered events)
  const totalMinutes = filteredEvents.reduce((sum, evt) => sum + evt.duration, 0);
  const totalHours = Math.floor(totalMinutes / 60);
  const totalMins = totalMinutes % 60;

  // Calculate time distribution by project (based on filtered events)
  const projectTimeMap = new Map<number, number>();
  filteredEvents.forEach((evt) => {
    if (evt.projectId) {
      projectTimeMap.set(evt.projectId, (projectTimeMap.get(evt.projectId) || 0) + evt.duration);
    }
  });

  const projectsWithTime = projects.map((p) => ({
    ...p,
    duration: projectTimeMap.get(p.id) || 0,
    percent: totalMinutes > 0 ? Math.round((projectTimeMap.get(p.id) || 0) / totalMinutes * 100) : 0,
  }));

  return (
    <View style={{ flex: 1, backgroundColor: '#F9FAFB' }}>
      <Header title="Analytics" subtitle="Track your focus" />

      <ScrollView
        style={{ flex: 1, paddingHorizontal: 16, paddingTop: 12 }}
        contentContainerStyle={{ paddingBottom: 24 }}
      >
        <View style={styles.toggleContainer}>
          {(['Week', 'Month'] as const).map((range) => {
            const active = timeRange === range;
            return (
              <Pressable
                key={range}
                style={[styles.toggleItem, active && styles.toggleItemActive]}
                onPress={() => setTimeRange(range)}
              >
                <Text
                  style={[
                    styles.toggleText,
                    active && styles.toggleTextActive,
                  ]}
                >
                  Last {range}
                </Text>
              </Pressable>
            );
          })}
        </View>

        <View style={styles.analyticsCard}>
          <View style={styles.analyticsHeader}>
            <Text style={styles.analyticsTitle}>Total Focus</Text>
            <Text style={styles.analyticsValue}>
              {totalHours}<Text style={styles.analyticsValueUnit}>h</Text> {totalMins}
              <Text style={styles.analyticsValueUnit}>m</Text>
            </Text>
          </View>
          <View style={styles.barChartRow}>
            {weeklyData.map((val, idx) => {
              const height = maxVal ? (val / maxVal) * 100 : 0;
              return (
                <View key={idx} style={styles.barWrapper}>
                  <View style={styles.barBackground}>
                    <View
                      style={[
                        styles.barFill,
                        {
                          height: `${height}%`,
                          backgroundColor: APP_COLORS[idx % APP_COLORS.length],
                        },
                      ]}
                    />
                  </View>
                  <Text style={styles.barLabel}>{days[idx]}</Text>
                </View>
              );
            })}
          </View>
        </View>

        <Text style={styles.sectionTitle}>Time Distribution</Text>
        {projectsWithTime.map((p) => {
          const hours = Math.floor(p.duration / 60);
          const mins = p.duration % 60;
          return (
            <View key={p.id} style={styles.projectRow}>
              <View style={styles.projectRowHeader}>
                <View style={styles.projectRowLeft}>
                  <View
                    style={[
                      styles.projectDot,
                      { backgroundColor: p.hexColor },
                    ]}
                  />
                  <Text style={styles.projectRowName}>{p.name}</Text>
                </View>
                <Text style={styles.projectRowTime}>
                  {hours}h {mins}m
                </Text>
              </View>
              <View style={styles.progressTrack}>
                <View
                  style={[
                    styles.progressFill,
                    { width: `${p.percent}%`, backgroundColor: p.hexColor },
                  ]}
                />
              </View>
            </View>
          );
        })}
      </ScrollView>
    </View>
  );
};

// --- Project Graph View ---

// --- Analytics View ---
  const [importStatus, setImportStatus] = useState<string>('');
  const [importError, setImportError] = useState<string>('');

  // æ‹–æ‹½çŠ¶æ€ï¼ˆä»¥â€œä¸­å¿ƒåæ ‡â€ä¸ºåŸºå‡†ï¼‰
  const dragStateRef = useRef<{
    id: number;
    startX: number;
    startY: number;
    touchX: number;
    touchY: number;
  } | null>(null);

  const handleExport = () => {
    const data = {
      projects,
      events,
      links,
      categories,
      exportDate: new Date().toISOString(),
    };
    const jsonString = JSON.stringify(data, null, 2);
    console.log('Export data:', jsonString);
    setImportStatus(`âœ“ Export data created`);
    setTimeout(() => setImportStatus(''), 3000);
  };

  const handleImport = (jsonString: string) => {
    try {
      setImportError('');
      const data = JSON.parse(jsonString);
      
      if (Array.isArray(data) && data.length > 0 && (data[0].date || data[0].time || data[0].tag)) {
        const transformed = transformCustomFormat(data);
        setProjects(() => transformed.projects);
        setEvents(() => transformed.events);
        setLinks(() => transformed.links);
        setCategories(() => transformed.categories);
        setImportStatus(`âœ“ Data imported successfully (${data.length} items)`);
        setImportText('');
        setTimeout(() => setImportStatus(''), 3000);
        return;
      }
      
      if (!data.projects || !Array.isArray(data.projects)) {
        throw new Error('Invalid format: missing projects array');
      }
      if (!data.events || !Array.isArray(data.events)) {
        throw new Error('Invalid format: missing events array');
      }
      if (!data.links || !Array.isArray(data.links)) {
        throw new Error('Invalid format: missing links array');
      }

      setProjects(() => data.projects);
      setEvents(() => data.events);
      setLinks(() => data.links);
      if (data.categories) {
        setCategories(() => data.categories);
      }

      setImportStatus('âœ“ Data imported successfully');
      setImportText('');
      setTimeout(() => setImportStatus(''), 3000);
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      setImportError(`âœ— Import failed: ${errorMsg}`);
    }
  };

  const handleClearData = () => {
    Alert.alert(
      'Clear All Data',
      'Are you sure you want to clear all data? This cannot be undone.',
      [
        { text: 'Cancel', onPress: () => {}, style: 'cancel' },
        {
          text: 'Clear',
          onPress: async () => {
            try {
              await clearAppData();
              setProjects(() => []);
              setEvents(() => []);
              setLinks(() => []);
              setCategories(() => ({}));
              setImportStatus('âœ“ All data cleared');
              setImportText('');
              setTimeout(() => setImportStatus(''), 3000);
            } catch (error) {
              const errorMsg = error instanceof Error ? error.message : 'Unknown error';
              setImportError(`âœ— Failed to clear data: ${errorMsg}`);
            }
          },
          style: 'destructive',
        },
      ]
    );
  };

  const openEdit = (p: Project) => {
    setSelected(p);
    setGraphModalVisible(true);
  };

  const closeEdit = () => {
    setGraphModalVisible(false);
    setSelected(null);
  };

  const handleSave = () => {
    if (!selected) return;
    setProjects((prev) => prev.map((p) => (p.id === selected.id ? selected : p)));
    closeEdit();
  };

  const isConnected = (targetId: number) => {
    if (!selected) return false;
    return links.some(
      (l) =>
        (l.source === selected.id && l.target === targetId) ||
        (l.source === targetId && l.target === selected.id),
    );
  };

  const toggleConnection = (targetId: number) => {
    if (!selected) return;
    setLinks((prev) => {
      const exists = prev.some(
        (l) =>
          (l.source === selected.id && l.target === targetId) ||
          (l.source === targetId && l.target === selected.id),
      );
      if (exists) {
        return prev.filter(
          (l) =>
            !(
              (l.source === selected.id && l.target === targetId) ||
              (l.source === targetId && l.target === selected.id)
            ),
        );
      }
      return [...prev, { source: selected.id, target: targetId }];
    });
  };

  // ----- æ‹–æ‹½ç›¸å…³ -----

  const handleDragStart = (project: Project, e: any) => {
    const { pageX, pageY } = e.nativeEvent;
    dragStateRef.current = {
      id: project.id,
      startX: project.x,
      startY: project.y,
      touchX: pageX,
      touchY: pageY,
    };
  };

  const handleDragMove = (project: Project, e: any) => {
    const state = dragStateRef.current;
    if (!state || state.id !== project.id) return;

    const { pageX, pageY } = e.nativeEvent;
    const dx = pageX - state.touchX;
    const dy = pageY - state.touchY;

    const newX = state.startX + dx;
    const newY = state.startY + dy;

    setProjects((prev) =>
      prev.map((p) => (p.id === project.id ? { ...p, x: newX, y: newY } : p)),
    );
  };

  const handleDragEnd = (project: Project, e: any) => {
    const state = dragStateRef.current;
    if (!state || state.id !== project.id) {
      dragStateRef.current = null;
      return;
    }

    const { pageX, pageY } = e.nativeEvent;
    const dx = pageX - state.touchX;
    const dy = pageY - state.touchY;
    const distSq = dx * dx + dy * dy;

    dragStateRef.current = null;

    // ç§»åŠ¨è·ç¦»å¾ˆå°ï¼Œå½“ä½œâ€œç‚¹ä¸€ä¸‹â€ï¼Œæ‰“å¼€ç¼–è¾‘å¼¹çª—
    if (distSq < 25) {
      openEdit(project);
    }
  };

  // ----- æ¸²æŸ“ -----

  const NODE_RADIUS = NODE_SIZE / 2;

  return (
    <View style={{ flex: 1, backgroundColor: '#F3F4F6' }}>
      <Header 
        title="Project Map" 
        subtitle="Drag to move Â· Tap to edit"
        rightIcon={
          <Pressable onPress={() => setSettingsModalVisible(true)}>
            <Sliders size={24} color="#000" />
          </Pressable>
        }
      />

      {/* å›¾èŠ‚ç‚¹ + è¿çº¿ç”»å¸ƒ */}
      <View style={styles.graphCanvas}>
        {/* è¿çº¿ï¼šæŒ‰åœ†å¿ƒç®—ï¼Œå¹¶å‰ªæ‰ä¸¤ç«¯åŠå¾„ï¼Œè®©çº¿æ¥åˆ°åœ†è¾¹ä¸Š */}
        {links.map((l, idx) => {
          const s = projects.find((p) => p.id === l.source);
          const t = projects.find((p) => p.id === l.target);
          if (!s || !t) return null;

          const dx = t.x - s.x;
          const dy = t.y - s.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;

          // å¦‚æœä¸¤ä¸ªç‚¹å¤ªè¿‘å°±ä¸ç”»çº¿ï¼Œé¿å… length å˜è´Ÿ
          if (dist < NODE_RADIUS * 1.2) return null;

          const ux = dx / dist;
          const uy = dy / dist;

          const startX = s.x + ux * NODE_RADIUS;
          const startY = s.y + uy * NODE_RADIUS;
          const endX = t.x - ux * NODE_RADIUS;
          const endY = t.y - uy * NODE_RADIUS;

          const segDx = endX - startX;
          const segDy = endY - startY;
          const length = Math.sqrt(segDx * segDx + segDy * segDy);
          const angle = (Math.atan2(segDy, segDx) * 180) / Math.PI;

          const midX = (startX + endX) / 2;
          const midY = (startY + endY) / 2;

          return (
            <View
              key={idx}
              style={[
                styles.graphLinkLine,
                {
                  width: length,
                  transform: [
                    { translateX: midX - length / 2 },
                    { translateY: midY },
                    { rotateZ: `${angle}deg` },
                  ],
                },
              ]}
            />
          );
        })}

        {/* èŠ‚ç‚¹ï¼šç»å¯¹å®šä½ï¼Œæ”¯æŒæ‹–æ‹½ + ç‚¹å‡» */}
        {projects.map((p) => (
          <View
            key={p.id}
            style={[
              styles.graphNodeWrapper,
              {
                left: p.x - NODE_RADIUS,
                top: p.y - NODE_RADIUS,
              },
            ]}
            onStartShouldSetResponder={() => true}
            onResponderGrant={(e) => handleDragStart(p, e)}
            onResponderMove={(e) => handleDragMove(p, e)}
            onResponderRelease={(e) => handleDragEnd(p, e)}
            onResponderTerminationRequest={() => false}
          >
            <View
              style={[
                styles.graphNodeOuter,
                { borderColor: `${p.hexColor}40` },
              ]}
            >
              <View
                style={[
                  styles.graphNodeInner,
                  { backgroundColor: p.hexColor },
                ]}
              >
                <Text style={styles.graphNodeInitial}>
                  {p.name.charAt(0).toUpperCase()}
                </Text>
              </View>

              {p.category ? (
                <View
                  style={[
                    styles.graphCategoryBadge,
                    { backgroundColor: `${p.hexColor}1A` },
                  ]}
                >
                  <Text style={styles.graphCategoryText} numberOfLines={1}>
                    {p.category}
                  </Text>
                </View>
              ) : null}
            </View>

            <Text style={styles.graphNodeLabel} numberOfLines={1}>
              {p.name}
            </Text>
          </View>
        ))}
      </View>

      {/* ç¼–è¾‘ Modalï¼ˆä½ åŸæ¥çš„é‚£ä¸€æ®µå‡ ä¹ä¸åŠ¨ï¼Œåªæ˜¯ç”¨ selected / toggleConnectionï¼‰ */}
      <Modal visible={graphModalVisible && !!selected} transparent animationType="slide">
        <Pressable 
          style={styles.modalOverlay}
          onPress={() => closeEdit()}
        >
          <View 
            style={styles.bottomSheetLarge}
            onStartShouldSetResponder={() => true}
            onResponderRelease={() => {}}
          >
            {/* å¤´éƒ¨ */}
            <View className="sheetHeader" style={styles.sheetHeader}>
              <Text style={styles.sheetTitle}>
                {selected ? selected.name : 'Edit Project'}
              </Text>
              <Pressable style={styles.iconButton} onPress={closeEdit}>
                <X size={20} color="#6B7280" />
              </Pressable>
            </View>

            {selected && (
              <ScrollView
                style={{ marginTop: 8 }}
                contentContainerStyle={{ paddingBottom: 16 }}
              >
                {/* Name */}
                <View style={styles.card}>
                  <Text style={styles.sectionLabel}>Name</Text>
                  <TextInput
                    style={styles.input}
                    value={selected.name}
                    onChangeText={(txt) =>
                      setSelected((prev) => (prev ? { ...prev, name: txt } : prev))
                    }
                  />
                </View>

                {/* Category */}
                <View style={styles.card}>
                  <Text style={styles.sectionLabel}>Category</Text>
                  
                  {/* Saved Categories - horizontal scroll */}
                  {Object.keys(categories).length > 0 && (
                    <View style={{ marginBottom: 12 }}>
                      <Text style={[styles.sectionLabel, { fontSize: 12, color: '#6B7280', marginBottom: 8 }]}>
                        Saved Categories
                      </Text>
                      <View style={{ flexDirection: 'row', gap: 8, flexWrap: 'wrap' }}>
                        {Object.keys(categories).map((catName) => {
                          const catColor = categories[catName];
                          const isSelected = selected.category === catName;
                          return (
                            <Pressable
                              key={catName}
                              style={[
                                {
                                  paddingHorizontal: 12,
                                  paddingVertical: 6,
                                  borderRadius: 8,
                                  backgroundColor: `${catColor}20`,
                                  borderColor: catColor,
                                  borderWidth: 2,
                                },
                                isSelected && { backgroundColor: catColor, borderColor: catColor, borderWidth: 2 },
                              ]}
                              onPress={() => {
                                setSelected((prev) =>
                                  prev ? { ...prev, category: catName } : prev,
                                );
                              }}
                            >
                              <Text
                                style={[
                                  { color: catColor, fontWeight: '600', fontSize: 12 },
                                  isSelected && { color: '#FFFFFF' },
                                ]}
                              >
                                {catName}
                              </Text>
                            </Pressable>
                          );
                        })}
                      </View>
                    </View>
                  )}

                  {/* Create/Edit Category */}
                  <View style={{ marginBottom: 8 }}>
                    <Text style={[styles.sectionLabel, { fontSize: 12, color: '#6B7280', marginBottom: 8 }]}>
                      {selected.category && Object.keys(categories).includes(selected.category) ? 'Edit Category' : 'Create New Category'}
                    </Text>
                    <TextInput
                      style={styles.input}
                      placeholder="Enter category name..."
                      value={selected.category ?? ''}
                      onChangeText={(txt) =>
                        setSelected((prev) =>
                          prev ? { ...prev, category: txt || null } : prev,
                        )
                      }
                    />
                  </View>

                  {/* Category Color Picker */}
                  {selected.category && selected.category.trim() && (
                    <View>
                      <Text style={[styles.sectionLabel, { fontSize: 12, color: '#6B7280', marginBottom: 8 }]}>
                        Category Color
                      </Text>
                      <View style={{ flexDirection: 'row', gap: 12, marginTop: 4, flexWrap: 'wrap' }}>
                        {CATEGORY_COLORS.map((color) => {
                          const catColor = categories[selected.category!] ?? null;
                          const active = catColor === color;
                          // Check if this color is used by another category
                          const colorUsedByOther = Object.entries(categories).some(
                            ([name, col]) => col === color && name !== selected.category
                          );
                          const isDisabled = colorUsedByOther && !active;
                          
                          return (
                            <Pressable
                              key={color}
                              style={[
                                styles.colorDotLarge,
                                { backgroundColor: color, opacity: isDisabled ? 0.5 : 1 },
                                active && styles.colorDotLargeActive,
                              ]}
                              onPress={() => {
                                if (!isDisabled) {
                                  // Update or add category color mapping
                                  setCategories((prev) => {
                                    const updated = { ...prev };
                                    updated[selected.category!] = color;
                                    return updated;
                                  });
                                }
                              }}
                              disabled={isDisabled}
                            />
                          );
                        })}
                      </View>
                      {Object.values(categories).includes(categories[selected.category!]) && 
                        Object.entries(categories).some(([name, col]) => col === categories[selected.category!] && name !== selected.category) && (
                        <Text style={{ fontSize: 12, color: '#F97316', marginTop: 8 }}>
                          âš ï¸ Each color can only be assigned to one category
                        </Text>
                      )}
                    </View>
                  )}
                </View>

                {/* Connections */}
                <View style={styles.card}>
                  <Text style={styles.sectionLabel}>Connections</Text>
                  {projects
                    .filter((p) => p.id !== selected.id)
                    .map((p) => {
                      const connected = isConnected(p.id);
                      return (
                        <Pressable
                          key={p.id}
                          style={styles.connectionRow}
                          onPress={() => toggleConnection(p.id)}
                        >
                          <View
                            style={[
                              styles.checkboxBox,
                              connected && styles.checkboxBoxActive,
                            ]}
                          />
                          <Text style={styles.checkboxLabel}>{p.name}</Text>
                        </Pressable>
                      );
                    })}

                  {projects.length <= 1 && (
                    <Text style={styles.emptyText}>
                      Create more projects to connect them.
                    </Text>
                  )}
                </View>
              </ScrollView>
            )}

            <Pressable style={styles.primaryButton} onPress={handleSave}>
              <Text style={styles.primaryButtonText}>Save Changes</Text>
            </Pressable>
          </View>
        </Pressable>
      </Modal>

      {/* Settings Modal */}
      <Modal visible={settingsModalVisible} transparent animationType="slide">
        <Pressable 
          style={styles.modalOverlay}
          onPress={() => setSettingsModalVisible(false)}
        />
        <Pressable 
          style={[styles.card, { backgroundColor: '#FFFFFF', marginHorizontal: 16, marginVertical: 100, borderRadius: 16 }]}
          onPress={(e) => e.stopPropagation()}
        >
          <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 16 }}>
            <Text style={styles.sectionTitle}>Data Management</Text>
            <Pressable onPress={() => setSettingsModalVisible(false)}>
              <X size={24} color="#000" />
            </Pressable>
          </View>

          <ScrollView style={{ maxHeight: 400 }} contentContainerStyle={{ gap: 12 }}>
            {importStatus && (
              <View style={[styles.card, { backgroundColor: '#D1FAE5', borderLeftColor: '#10B981', borderLeftWidth: 4 }]}>
                <Text style={{ color: '#10B981', fontWeight: '600', fontSize: 14 }}>{importStatus}</Text>
              </View>
            )}
            
            {importError && (
              <View style={[styles.card, { backgroundColor: '#FEE2E2', borderLeftColor: '#EF4444', borderLeftWidth: 4 }]}>
                <Text style={{ color: '#EF4444', fontWeight: '600', fontSize: 14 }}>{importError}</Text>
              </View>
            )}

            <Pressable style={styles.primaryButton} onPress={handleExport}>
              <Text style={styles.primaryButtonText}>ğŸ“¥ Export Data</Text>
            </Pressable>

            <Pressable 
              style={[styles.primaryButton, { backgroundColor: '#EF4444' }]} 
              onPress={handleClearData}
            >
              <Text style={styles.primaryButtonText}>ğŸ—‘ Clear All Data</Text>
            </Pressable>

            <TextInput
              style={[styles.input, { minHeight: 120, textAlignVertical: 'top' }]}
              placeholder="Paste JSON to import..."
              placeholderTextColor="#D1D5DB"
              multiline
              value={importText}
              onChangeText={(text) => {
                setImportText(text);
                if (text.trim()) {
                  handleImport(text);
                }
              }}
            />
          </ScrollView>
        </Pressable>
      </Modal>
    </View>
  );
};

// --- Data View (Import/Export) ---

type DataViewProps = {
  projects: Project[];
  setProjects: React.Dispatch<React.SetStateAction<Project[]>>;
  events: EventItem[];
  setEvents: React.Dispatch<React.SetStateAction<EventItem[]>>;
  links: Link[];
  setLinks: React.Dispatch<React.SetStateAction<Link[]>>;
  categories: CategoryMap;
  setCategories: React.Dispatch<React.SetStateAction<CategoryMap>>;
};

const DataView: React.FC<DataViewProps> = ({
  projects,
  setProjects,
  events,
  setEvents,
  links,
  setLinks,
  categories,
  setCategories,
}) => {
  const [importStatus, setImportStatus] = useState<string>('');
  const [importError, setImportError] = useState<string>('');

  const handleExport = () => {
    const data = {
      projects,
      events,
      links,
      categories,
      exportDate: new Date().toISOString(),
    };
    
    const jsonString = JSON.stringify(data, null, 2);
    // For web, we'd use a Blob/download approach
    // For now, we'll copy to clipboard or show a message
    const timestamp = new Date().toISOString().slice(0, 10);
    console.log('Export data:', jsonString);
    setImportStatus(`âœ“ Export data created (${timestamp})`);
    setTimeout(() => setImportStatus(''), 3000);
  };

  const handleImport = (jsonString: string) => {
    try {
      setImportError('');
      const data = JSON.parse(jsonString);
      
      // Check if it's the custom format (array of objects with date, time, tag, type, project)
      if (Array.isArray(data) && data.length > 0 && (data[0].date || data[0].time || data[0].tag)) {
        // Import custom format
        const transformed = transformCustomFormat(data);
        setProjects(() => transformed.projects);
        setEvents(() => transformed.events);
        setLinks(() => transformed.links);
        setCategories(() => transformed.categories);
        setImportStatus(`âœ“ Data imported successfully (${data.length} items)`);
        setTimeout(() => setImportStatus(''), 3000);
        return;
      }
      
      // Standard format validation
      if (!data.projects || !Array.isArray(data.projects)) {
        throw new Error('Invalid format: missing projects array');
      }
      if (!data.events || !Array.isArray(data.events)) {
        throw new Error('Invalid format: missing events array');
      }
      if (!data.links || !Array.isArray(data.links)) {
        throw new Error('Invalid format: missing links array');
      }

      // Import standard format data
      setProjects(() => data.projects);
      setEvents(() => data.events);
      setLinks(() => data.links);
      if (data.categories) {
        setCategories(() => data.categories);
      }

      setImportStatus('âœ“ Data imported successfully');
      setTimeout(() => setImportStatus(''), 3000);
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      setImportError(`âœ— Import failed: ${errorMsg}`);
    }
  };

  return (
    <View style={{ flex: 1, backgroundColor: '#FFFFFF' }}>
      <Header title="Data Management" subtitle="Import & Export" />
      
      <ScrollView style={{ flex: 1 }} contentContainerStyle={{ paddingHorizontal: 16, paddingVertical: 20 }}>
        {/* Status Messages */}
        {importStatus && (
          <View style={[styles.card, { backgroundColor: '#D1FAE5', borderLeftColor: '#10B981', borderLeftWidth: 4 }]}>
            <Text style={{ color: '#10B981', fontWeight: '600', fontSize: 14 }}>{importStatus}</Text>
          </View>
        )}
        
        {importError && (
          <View style={[styles.card, { backgroundColor: '#FEE2E2', borderLeftColor: '#EF4444', borderLeftWidth: 4 }]}>
            <Text style={{ color: '#EF4444', fontWeight: '600', fontSize: 14 }}>{importError}</Text>
          </View>
        )}

        {/* Export Section */}
        <View style={styles.card}>
          <Text style={styles.sectionLabel}>Export Data</Text>
          <Text style={{ color: '#6B7280', fontSize: 13, marginBottom: 12, lineHeight: 20 }}>
            Export all your projects, events, links, and categories as a JSON file. You can save this file and import it later.
          </Text>
          <Pressable style={styles.primaryButton} onPress={handleExport}>
            <Text style={styles.primaryButtonText}>ğŸ“¥ Export as JSON</Text>
          </Pressable>
        </View>

        {/* Import Section */}
        <View style={styles.card}>
          <Text style={styles.sectionLabel}>Import Data</Text>
          <Text style={{ color: '#6B7280', fontSize: 13, marginBottom: 12, lineHeight: 20 }}>
            Paste your JSON data below to import projects, events, links, and categories.
          </Text>
          <TextInput
            style={[styles.input, { minHeight: 200, textAlignVertical: 'top', fontFamily: 'Courier' }]}
            placeholder='Paste your JSON data here...'
            placeholderTextColor="#D1D5DB"
            multiline
            onChangeText={(text) => {
              if (text.trim()) {
                handleImport(text);
              }
            }}
          />
        </View>

        {/* Data Summary */}
        <View style={styles.card}>
          <Text style={styles.sectionLabel}>Current Data</Text>
          <View style={{ gap: 8 }}>
            <View style={{ flexDirection: 'row', justifyContent: 'space-between', paddingVertical: 8, borderBottomColor: '#E5E7EB', borderBottomWidth: 1 }}>
              <Text style={{ color: '#6B7280', fontSize: 13 }}>Projects:</Text>
              <Text style={{ fontWeight: '600', fontSize: 13 }}>{projects.length}</Text>
            </View>
            <View style={{ flexDirection: 'row', justifyContent: 'space-between', paddingVertical: 8, borderBottomColor: '#E5E7EB', borderBottomWidth: 1 }}>
              <Text style={{ color: '#6B7280', fontSize: 13 }}>Events:</Text>
              <Text style={{ fontWeight: '600', fontSize: 13 }}>{events.length}</Text>
            </View>
            <View style={{ flexDirection: 'row', justifyContent: 'space-between', paddingVertical: 8, borderBottomColor: '#E5E7EB', borderBottomWidth: 1 }}>
              <Text style={{ color: '#6B7280', fontSize: 13 }}>Links:</Text>
              <Text style={{ fontWeight: '600', fontSize: 13 }}>{links.length}</Text>
            </View>
            <View style={{ flexDirection: 'row', justifyContent: 'space-between', paddingVertical: 8 }}>
              <Text style={{ color: '#6B7280', fontSize: 13 }}>Categories:</Text>
              <Text style={{ fontWeight: '600', fontSize: 13 }}>{Object.keys(categories).length}</Text>
            </View>
          </View>
        </View>

        {/* Reset Warning */}
        <View style={[styles.card, { backgroundColor: '#FEF3C7', borderLeftColor: '#F59E0B', borderLeftWidth: 4 }]}>
          <Text style={{ color: '#92400E', fontWeight: '600', fontSize: 13, marginBottom: 8 }}>âš ï¸ Warning</Text>
          <Text style={{ color: '#92400E', fontSize: 12, lineHeight: 18 }}>
            Importing data will replace your current projects, events, and categories. Make sure to export first if you want to keep your current data.
          </Text>
        </View>
      </ScrollView>
    </View>
  );
};



// --- MAIN APP ---

const App: React.FC = () => {
  const [activeTab, setActiveTab] = useState<TabKey>('calendar');
  const [projects, setProjects] = useState<Project[]>([]);
  const [events, setEvents] = useState<EventItem[]>([]);
  const [links, setLinks] = useState<Link[]>([]);
  const [categories, setCategories] = useState<CategoryMap>({});

  // Initialize data persistence
  useAppData(projects, events, links, categories, setProjects, setEvents, setLinks, setCategories);

  const today = new Date();
  const dateStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(
    2,
    '0',
  )}-${String(today.getDate()).padStart(2, '0')}`;

  let content: React.ReactNode;
  if (activeTab === 'calendar') {
    content = (
      <CalendarView
        events={events}
        setEvents={setEvents}
        projects={projects}
        setProjects={setProjects}
        categories={categories}
        setCategories={setCategories}
      />
    );
  } else if (activeTab === 'analytics') {
    content = <AnalyticsView projects={projects} events={events} />;
  } else {
    content = (
      <DataView
        projects={projects}
        setProjects={setProjects}
        events={events}
        setEvents={setEvents}
        links={links}
        setLinks={setLinks}
        categories={categories}
        setCategories={setCategories}
      />
    );
  }

  return (
    <SafeAreaView style={styles.safe}>
      <StatusBar barStyle="dark-content" />
      <View style={styles.appContainer}>
        <View style={styles.topStrip}>
          <Text style={styles.topStripText}>Today Â· {dateStr}</Text>
        </View>

        <View style={{ flex: 1 }}>{content}</View>

        <TabBar activeTab={activeTab} setActiveTab={setActiveTab} />
      </View>
    </SafeAreaView>
  );
};

export default App;

// --- STYLES ---

const styles = StyleSheet.create({
  safe: {
    flex: 1,
    backgroundColor: '#111827',
  },
  appContainer: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  topStrip: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderColor: '#E5E7EB',
  },
  topStripText: {
    fontSize: 12,
    color: '#6B7280',
  },
  header: {
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderColor: '#E5E7EB',
    flexDirection: 'row',
    alignItems: 'flex-end',
    justifyContent: 'space-between',
    backgroundColor: '#FFFFFF',
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'flex-end',
  },
  headerTitle: {
    fontSize: 22,
    fontWeight: '700',
    color: '#111827',
  },
  headerSubtitle: {
    fontSize: 13,
    color: '#6B7280',
    marginTop: 2,
  },
  iconButton: {
    padding: 6,
    borderRadius: 999,
    backgroundColor: '#F3F4F6',
  },
  iconDanger: {
    padding: 6,
    borderRadius: 999,
    backgroundColor: '#FEE2E2',
  },
  fabSmall: {
    padding: 8,
    borderRadius: 999,
    backgroundColor: '#000000',
  },
  todayButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 8,
    backgroundColor: '#E5E7EB',
  },
  todayButtonText: {
    fontSize: 12,
    fontWeight: '600',
    color: '#111827',
  },
  calendarBackdrop: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 999,
  },
  calendarDropdown: {
    position: 'absolute',
    top: 80,
    left: 16,
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#E5E7EB',
    shadowColor: '#000',
    shadowOpacity: 0.1,
    shadowOffset: { width: 0, height: 4 },
    shadowRadius: 8,
    elevation: 5,
    paddingHorizontal: 12,
    paddingVertical: 12,
    zIndex: 1000,
  },
  calendarHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  calendarNavText: {
    fontSize: 18,
    fontWeight: '600',
    color: '#111827',
    paddingHorizontal: 8,
  },
  calendarMonth: {
    fontSize: 14,
    fontWeight: '600',
    color: '#111827',
  },
  calendarWeekdays: {
    flexDirection: 'row',
    marginBottom: 8,
    justifyContent: 'space-between',
  },
  calendarWeekdayLabel: {
    fontSize: 11,
    fontWeight: '600',
    color: '#6B7280',
    width: 32,
    textAlign: 'center',
  },
  calendarGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 8,
  },
  calendarEmptyCell: {
    width: 32,
    height: 32,
  },
  calendarDay: {
    width: 32,
    height: 32,
    borderRadius: 6,
    justifyContent: 'center',
    alignItems: 'center',
    marginHorizontal: 2,
    marginVertical: 2,
  },
  calendarDaySelected: {
    backgroundColor: '#000000',
  },
  calendarDayToday: {
    borderWidth: 2,
    borderColor: '#000000',
  },
  calendarDayText: {
    fontSize: 13,
    color: '#111827',
    fontWeight: '500',
  },
  calendarDayTextSelected: {
    color: '#FFFFFF',
    fontWeight: '600',
  },
  calendarEventDot: {
    width: 4,
    height: 4,
    borderRadius: 2,
    backgroundColor: '#EF4444',
    position: 'absolute',
    bottom: 4,
  },
  tabBar: {
    flexDirection: 'row',
    height: 64,
    borderTopWidth: StyleSheet.hairlineWidth,
    borderColor: '#E5E7EB',
    backgroundColor: '#FFFFFF',
    alignItems: 'center',
    justifyContent: 'space-around',
  },
  tabItem: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  tabLabel: {
    fontSize: 10,
    marginTop: 2,
    fontWeight: '500',
  },
  hourRow: {
    flexDirection: 'row',
    alignItems: 'stretch',
  },
  hourLabelContainer: {
    width: 48,
    justifyContent: 'flex-start',
    alignItems: 'flex-end',
    paddingRight: 4,
  },
  hourLabel: {
    fontSize: 11,
    color: '#9CA3AF',
  },
  hourTrack: {
    flex: 1,
    borderTopWidth: StyleSheet.hairlineWidth,
    position: 'relative',
  },
  eventCard: {
    position: 'absolute',
    left: 60,
    right: 16,
    borderRadius: 8,
    borderLeftWidth: 4,
    paddingHorizontal: 8,
    paddingVertical: 2,
    justifyContent: 'flex-start',
    shadowColor: '#000',
    shadowOpacity: 0.05,
    shadowOffset: { width: 0, height: 1 },
    shadowRadius: 2,
  },
  eventTitle: {
    fontSize: 12,
    fontWeight: '600',
    color: '#111827',
  },
  eventTime: {
    fontSize: 10,
    color: '#6B7280',
  },
  nowLine: {
    position: 'absolute',
    left: 60,
    right: 0,
    borderTopWidth: 2,
    borderTopColor: '#EF4444',
    flexDirection: 'row',
    alignItems: 'center',
  },
  nowDot: {
    width: 6,
    height: 6,
    borderRadius: 999,
    backgroundColor: '#EF4444',
    marginLeft: -3,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.2)',
    justifyContent: 'flex-end',
  },
  bottomSheet: {
    backgroundColor: '#FFFFFF',
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    padding: 16,
  },
  bottomSheetLarge: {
    backgroundColor: '#FFFFFF',
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    padding: 16,
    // åŸæ¥æ˜¯ maxHeight: '85%',
    height: '75%',             // æˆ–è€… '70%' / '80%'ï¼Œçœ‹ä½ å–œæ¬¢å¤šé«˜
    flexDirection: 'column',
  },

  sheetHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  sheetTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#111827',
  },
  card: {
    backgroundColor: '#F9FAFB',
    borderRadius: 16,
    padding: 12,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: '#E5E7EB',
    marginBottom: 12,
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
    gap: 8,
  },
  cardHeaderText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#374151',
  },
  segmentContainer: {
    flexDirection: 'row',
    backgroundColor: '#E5E7EB',
    borderRadius: 999,
    padding: 2,
  },
  segmentItem: {
    flex: 1,
    paddingVertical: 6,
    borderRadius: 999,
    alignItems: 'center',
    justifyContent: 'center',
  },
  segmentItemActive: {
    backgroundColor: '#111827',
  },
  segmentText: {
    fontSize: 13,
    color: '#4B5563',
  },
  segmentTextActive: {
    color: '#FFFFFF',
    fontWeight: '600',
  },
  resetButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: 14,
    paddingVertical: 12,
    backgroundColor: '#FEF2F2',
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: '#FCA5A5',
    gap: 8,
  },
  resetButtonText: {
    color: '#DC2626',
    fontWeight: '700',
    fontSize: 14,
  },
  sectionLabel: {
    fontSize: 12,
    color: '#6B7280',
    fontWeight: '600',
    marginBottom: 8,
    textTransform: 'uppercase',
  },
  timeCard: {
    borderRadius: 24,
    paddingHorizontal: 20,
    paddingVertical: 18,
    backgroundColor: '#F9FAFB',
    marginBottom: 12,
  },
    timePickerContainer: {
    backgroundColor: '#F9FAFB',
    borderRadius: 16,
    padding: 12,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: '#E5E7EB',
    marginBottom: 12,
  },
  timePickerTitle: {
    fontSize: 12,
    fontWeight: '600',
    color: '#6B7280',
    marginBottom: 8,
    textTransform: 'uppercase',
  },
  timeOptionRow: {
    paddingVertical: 8,
    paddingHorizontal: 10,
    borderRadius: 999,
    marginBottom: 4,
  },
  timeOptionRowActive: {
    backgroundColor: '#111827',
  },
  timeOptionText: {
    fontSize: 14,
    color: '#111827',
  },
  timeOptionTextActive: {
    color: '#FFFFFF',
    fontWeight: '600',
  },

  timeHeaderRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 8,
  },
  timeHeaderLabel: {
    fontSize: 12,
    fontWeight: '600',
    color: '#9CA3AF',
    letterSpacing: 1,
  },
  timeMainRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  timeBlock: {
    flex: 1,
    alignItems: 'center',
  },
  timeBig: {
    fontSize: 32,
    fontWeight: '700',
    color: '#111827',
  },
  timeArrow: {
    fontSize: 18,
    color: '#9CA3AF',
    paddingHorizontal: 4,
  },
  timeAdjustRowOuter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 16,
  },
  timeAdjustGroup: {
    flexDirection: 'row',
    gap: 8,
  },
  timeInput: {
    fontSize: 32,
    fontWeight: '700',
    color: '#111827',
    textAlign: 'center',
    minWidth: 80,
  },

  smallChip: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 999,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: '#D1D5DB',
    backgroundColor: '#FFFFFF',
  },
  smallChipText: {
    fontSize: 11,
    color: '#4B5563',
  },
  projectGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    marginBottom: 8,
  },
  projectChip: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: '#E5E7EB',
    backgroundColor: '#FFFFFF',
    maxWidth: '48%',
  },
  projectChipActive: {
    borderColor: '#111827',
    backgroundColor: '#E5E7EB',
  },
  projectChipText: {
    fontSize: 13,
    color: '#111827',
  },
  projectDot: {
    width: 8,
    height: 8,
    borderRadius: 999,
    marginRight: 6,
  },
  newProjectChip: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 999,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: '#D1D5DB',
    backgroundColor: '#FFFFFF',
    gap: 4,
  },
  newProjectChipActive: {
    borderColor: '#2563EB',
    backgroundColor: '#DBEAFE',
  },
  newProjectText: {
    fontSize: 13,
    color: '#6B7280',
  },
  input: {
    marginTop: 6,
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 12,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: '#D1D5DB',
    backgroundColor: '#FFFFFF',
    fontSize: 14,
    color: '#111827',
  },
  primaryButton: {
    marginTop: 8,
    marginBottom: 8,
    borderRadius: 16,
    paddingVertical: 14,
    alignItems: 'center',
    backgroundColor: '#000000',
  },
  primaryButtonText: {
    fontSize: 16,
    fontWeight: '700',
    color: '#FFFFFF',
  },
  toggleContainer: {
    flexDirection: 'row',
    backgroundColor: '#E5E7EB',
    borderRadius: 999,
    padding: 2,
    marginBottom: 16,
  },
  toggleItem: {
    flex: 1,
    paddingVertical: 6,
    borderRadius: 999,
    alignItems: 'center',
  },
  toggleItemActive: {
    backgroundColor: '#FFFFFF',
  },
  toggleText: {
    fontSize: 13,
    color: '#6B7280',
  },
  toggleTextActive: {
    color: '#111827',
    fontWeight: '600',
  },
  analyticsCard: {
    backgroundColor: '#FFFFFF',
    borderRadius: 20,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOpacity: 0.05,
    shadowOffset: { width: 0, height: 2 },
    shadowRadius: 4,
  },
  analyticsHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-end',
    marginBottom: 16,
  },
  analyticsTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#111827',
  },
  analyticsValue: {
    fontSize: 24,
    fontWeight: '700',
    color: '#111827',
  },
  analyticsValueUnit: {
    fontSize: 12,
    fontWeight: '400',
    color: '#6B7280',
  },
  barChartRow: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    height: 120,
    gap: 6,
  },
  barWrapper: {
    flex: 1,
    alignItems: 'center',
  },
  barBackground: {
    flex: 1,
    width: '100%',
    backgroundColor: '#EEF2FF',
    borderRadius: 4,
    justifyContent: 'flex-end',
    overflow: 'hidden',
  },
  barFill: {
    width: '100%',
    borderRadius: 4,
  },
  barLabel: {
    fontSize: 10,
    color: '#9CA3AF',
    marginTop: 4,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '700',
    color: '#111827',
    marginBottom: 8,
    marginTop: 8,
  },
  projectRow: {
    backgroundColor: '#FFFFFF',
    borderRadius: 14,
    padding: 12,
    marginBottom: 8,
    shadowColor: '#000',
    shadowOpacity: 0.03,
    shadowOffset: { width: 0, height: 1 },
    shadowRadius: 2,
  },
  projectRowHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 6,
  },
  projectRowLeft: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  projectRowName: {
    fontSize: 14,
    fontWeight: '600',
    color: '#111827',
  },
  projectRowTime: {
    fontSize: 12,
    color: '#4B5563',
  },
  projectCategory: {
    fontSize: 11,
    color: '#6B7280',
  },
  progressTrack: {
    height: 4,
    borderRadius: 999,
    backgroundColor: '#E5E7EB',
  },
  progressFill: {
    height: 4,
    borderRadius: 999,
  },
  projectCard: {
    backgroundColor: '#FFFFFF',
    borderRadius: 14,
    padding: 12,
    marginBottom: 8,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: '#E5E7EB',
  },
  emptyText: {
    fontSize: 13,
    color: '#9CA3AF',
    marginTop: 4,
  },
  linkRow: {
    paddingVertical: 8,
    borderBottomWidth: StyleSheet.hairlineWidth,
    borderColor: '#E5E7EB',
  },
  linkText: {
    fontSize: 13,
    color: '#4B5563',
  },
  helperText: {
    marginTop: 12,
    fontSize: 11,
    color: '#9CA3AF',
  },
  colorDotLarge: {
    width: 28,
    height: 28,
    borderRadius: 999,
    borderWidth: 2,
    borderColor: 'transparent',
  },
  colorDotLargeActive: {
    borderColor: '#111827',
  },
  connectionRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 8,
    gap: 8,
  },
  checkboxBox: {
    width: 18,
    height: 18,
    borderRadius: 4,
    borderWidth: StyleSheet.hairlineWidth,
    borderColor: '#D1D5DB',
    backgroundColor: '#FFFFFF',
  },
  checkboxBoxActive: {
    backgroundColor: '#111827',
    borderColor: '#111827',
  },
  checkboxLabel: {
    fontSize: 13,
    color: '#111827',
  },
  // --- Graph / Node Map ---
  graphCanvas: {
    flex: 1,
    backgroundColor: '#F3F4F6',
  },
  graphLinkLine: {
    position: 'absolute',
    height: 1.5,
    backgroundColor: '#CBD5E1',
  },
  graphNodeWrapper: {
    position: 'absolute',
    alignItems: 'center',
  },
  graphNodeOuter: {
    width: NODE_SIZE,
    height: NODE_SIZE,
    borderRadius: NODE_SIZE / 2,
    backgroundColor: '#FFFFFF',
    borderWidth: 4,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000000',
    shadowOpacity: 0.06,
    shadowOffset: { width: 0, height: 2 },
    shadowRadius: 4,
  },
  graphNodeInner: {
    width: NODE_SIZE - 16,
    height: NODE_SIZE - 16,
    borderRadius: (NODE_SIZE - 16) / 2,
    justifyContent: 'center',
    alignItems: 'center',
  },
  graphNodeInitial: {
    fontSize: 22,
    fontWeight: '700',
    color: '#FFFFFF',
  },
  graphCategoryBadge: {
    position: 'absolute',
    bottom: -10,
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 999,
  },
  graphCategoryText: {
    fontSize: 9,
    fontWeight: '600',
    color: '#374151',
  },
  graphNodeLabel: {
    marginTop: 4,
    fontSize: 12,
    fontWeight: '600',
    color: '#111827',
    alignSelf: 'center',
  },


});
